{"version":3,"sources":["slider/slider.ts"],"names":[],"mappings":"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","file":"slider/slider.js","sourcesContent":["import {\r\n  NgModule,\r\n  ModuleWithProviders,\r\n  Component,\r\n  ElementRef,\r\n  HostBinding,\r\n  Input,\r\n  ViewEncapsulation,\r\n  AfterContentInit,\r\n  forwardRef,\r\n} from '@angular/core';\r\nimport {\r\n  NG_VALUE_ACCESSOR,\r\n  ControlValueAccessor,\r\n  FormsModule,\r\n} from '@angular/forms';\r\nimport {HAMMER_GESTURE_CONFIG} from '@angular/platform-browser';\r\nimport {BooleanFieldValue, MdGestureConfig, applyCssTransform} from '@material-git/core';\r\nimport {Input as HammerInput} from 'hammerjs';\r\n\r\n/**\r\n * Visually, a 30px separation between tick marks looks best. This is very subjective but it is\r\n * the default separation we chose.\r\n */\r\nconst MIN_AUTO_TICK_SEPARATION = 30;\r\n\r\n/**\r\n * Provider Expression that allows md-slider to register as a ControlValueAccessor.\r\n * This allows it to support [(ngModel)] and [formControl].\r\n */\r\nexport const MD_SLIDER_VALUE_ACCESSOR: any = {\r\n  provide: NG_VALUE_ACCESSOR,\r\n  useExisting: forwardRef(() => MdSlider),\r\n  multi: true\r\n};\r\n\r\n@Component({\r\n  moduleId: module.id,\r\n  selector: 'md-slider',\r\n  providers: [MD_SLIDER_VALUE_ACCESSOR],\r\n  host: {\r\n    'tabindex': '0',\r\n    '(click)': 'onClick($event)',\r\n    '(slide)': 'onSlide($event)',\r\n    '(slidestart)': 'onSlideStart($event)',\r\n    '(slideend)': 'onSlideEnd()',\r\n    '(window:resize)': 'onResize()',\r\n    '(blur)': 'onBlur()',\r\n  },\r\n  templateUrl: 'slider.html',\r\n  styleUrls: ['slider.css'],\r\n  encapsulation: ViewEncapsulation.None,\r\n})\r\nexport class MdSlider implements AfterContentInit, ControlValueAccessor {\r\n  /** A renderer to handle updating the slider's thumb and fill track. */\r\n  private _renderer: SliderRenderer = null;\r\n\r\n  /** The dimensions of the slider. */\r\n  private _sliderDimensions: ClientRect = null;\r\n\r\n  @Input()\r\n  @BooleanFieldValue()\r\n  @HostBinding('class.md-slider-disabled')\r\n  @HostBinding('attr.aria-disabled')\r\n  disabled: boolean = false;\r\n\r\n  /** Whether or not to show the thumb label. */\r\n  @Input('thumb-label')\r\n  @BooleanFieldValue()\r\n  thumbLabel: boolean = false;\r\n\r\n  /** The miniumum value that the slider can have. */\r\n  private _min: number = 0;\r\n\r\n  /** The maximum value that the slider can have. */\r\n  private _max: number = 100;\r\n\r\n  /** The percentage of the slider that coincides with the value. */\r\n  private _percent: number = 0;\r\n\r\n  private _controlValueAccessorChangeFn: (value: any) => void = (value) => {};\r\n\r\n  /** onTouch function registered via registerOnTouch (ControlValueAccessor). */\r\n  onTouched: () => any = () => {};\r\n\r\n  /** The values at which the thumb will snap. */\r\n  @Input() step: number = 1;\r\n\r\n  /**\r\n   * How often to show ticks. Relative to the step so that a tick always appears on a step.\r\n   * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).\r\n   */\r\n  @Input('tick-interval') _tickInterval: 'auto' | number;\r\n\r\n  /**\r\n   * Whether or not the thumb is sliding.\r\n   * Used to determine if there should be a transition for the thumb and fill track.\r\n   * TODO: internal\r\n   */\r\n  isSliding: boolean = false;\r\n\r\n  /**\r\n   * Whether or not the slider is active (clicked or sliding).\r\n   * Used to shrink and grow the thumb as according to the Material Design spec.\r\n   * TODO: internal\r\n   */\r\n  isActive: boolean = false;\r\n\r\n  /** Indicator for if the value has been set or not. */\r\n  private _isInitialized: boolean = false;\r\n\r\n  /** Value of the slider. */\r\n  private _value: number = 0;\r\n\r\n  @Input()\r\n  @HostBinding('attr.aria-valuemin')\r\n  get min() {\r\n    return this._min;\r\n  }\r\n\r\n  set min(v: number) {\r\n    // This has to be forced as a number to handle the math later.\r\n    this._min = Number(v);\r\n\r\n    // If the value wasn't explicitly set by the user, set it to the min.\r\n    if (!this._isInitialized) {\r\n      this.value = this._min;\r\n    }\r\n  }\r\n\r\n  @Input()\r\n  @HostBinding('attr.aria-valuemax')\r\n  get max() {\r\n    return this._max;\r\n  }\r\n\r\n  set max(v: number) {\r\n    this._max = Number(v);\r\n  }\r\n\r\n  @Input()\r\n  @HostBinding('attr.aria-valuenow')\r\n  get value() {\r\n    return this._value;\r\n  }\r\n\r\n  set value(v: number) {\r\n    // Only set the value to a valid number. v is casted to an any as we know it will come in as a\r\n    // string but it is labeled as a number which causes parseFloat to not accept it.\r\n    if (isNaN(parseFloat(<any> v))) {\r\n      return;\r\n    }\r\n\r\n    this._value = Number(v);\r\n    this._isInitialized = true;\r\n    this._controlValueAccessorChangeFn(this._value);\r\n  }\r\n\r\n  constructor(elementRef: ElementRef) {\r\n    this._renderer = new SliderRenderer(elementRef);\r\n  }\r\n\r\n  /**\r\n   * Once the slider has rendered, grab the dimensions and update the position of the thumb and\r\n   * fill track.\r\n   * TODO: internal\r\n   */\r\n  ngAfterContentInit() {\r\n    this._sliderDimensions = this._renderer.getSliderDimensions();\r\n    // This needs to be called after content init because the value can be set to the min if the\r\n    // value itself isn't set. If this happens, the control value accessor needs to be updated.\r\n    this._controlValueAccessorChangeFn(this.value);\r\n    this.snapThumbToValue();\r\n    this._updateTickSeparation();\r\n  }\r\n\r\n  /** TODO: internal */\r\n  onClick(event: MouseEvent) {\r\n    if (this.disabled) {\r\n      return;\r\n    }\r\n\r\n    this.isActive = true;\r\n    this.isSliding = false;\r\n    this._renderer.addFocus();\r\n    this.updateValueFromPosition(event.clientX);\r\n    this.snapThumbToValue();\r\n  }\r\n\r\n  /** TODO: internal */\r\n  onSlide(event: HammerInput) {\r\n    if (this.disabled) {\r\n      return;\r\n    }\r\n\r\n    // Prevent the slide from selecting anything else.\r\n    event.preventDefault();\r\n    this.updateValueFromPosition(event.center.x);\r\n  }\r\n\r\n  /** TODO: internal */\r\n  onSlideStart(event: HammerInput) {\r\n    if (this.disabled) {\r\n      return;\r\n    }\r\n\r\n    event.preventDefault();\r\n    this.isSliding = true;\r\n    this.isActive = true;\r\n    this._renderer.addFocus();\r\n    this.updateValueFromPosition(event.center.x);\r\n  }\r\n\r\n  /** TODO: internal */\r\n  onSlideEnd() {\r\n    this.isSliding = false;\r\n    this.snapThumbToValue();\r\n  }\r\n\r\n  /** TODO: internal */\r\n  onResize() {\r\n    this.isSliding = true;\r\n    this._sliderDimensions = this._renderer.getSliderDimensions();\r\n    // Skip updating the value and position as there is no new placement.\r\n    this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\r\n  }\r\n\r\n  /** TODO: internal */\r\n  onBlur() {\r\n    this.isActive = false;\r\n    this.onTouched();\r\n  }\r\n\r\n  /**\r\n   * When the value changes without a physical position, the percentage needs to be recalculated\r\n   * independent of the physical location.\r\n   * This is also used to move the thumb to a snapped value once sliding is done.\r\n   */\r\n  updatePercentFromValue() {\r\n    this._percent = this.calculatePercentage(this.value);\r\n  }\r\n\r\n  /**\r\n   * Calculate the new value from the new physical location. The value will always be snapped.\r\n   */\r\n  updateValueFromPosition(pos: number) {\r\n    let offset = this._sliderDimensions.left;\r\n    let size = this._sliderDimensions.width;\r\n\r\n    // The exact value is calculated from the event and used to find the closest snap value.\r\n    this._percent = this.clamp((pos - offset) / size);\r\n    let exactValue = this.calculateValue(this._percent);\r\n\r\n    // This calculation finds the closest step by finding the closest whole number divisible by the\r\n    // step relative to the min.\r\n    let closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;\r\n    // The value needs to snap to the min and max.\r\n    this.value = this.clamp(closestValue, this.min, this.max);\r\n    this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\r\n  }\r\n\r\n  /**\r\n   * Snaps the thumb to the current value.\r\n   * Called after a click or drag event is over.\r\n   */\r\n  snapThumbToValue() {\r\n    this.updatePercentFromValue();\r\n    this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\r\n  }\r\n\r\n  /**\r\n   * Calculates the separation in pixels of tick marks. If there is no tick interval or the interval\r\n   * is set to something other than a number or 'auto', nothing happens.\r\n   */\r\n  private _updateTickSeparation() {\r\n    if (this._tickInterval == 'auto') {\r\n      this._updateAutoTickSeparation();\r\n    } else if (Number(this._tickInterval)) {\r\n      this._updateTickSeparationFromInterval();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates the optimal separation in pixels of tick marks based on the minimum auto tick\r\n   * separation constant.\r\n   */\r\n  private _updateAutoTickSeparation() {\r\n    // We're looking for the multiple of step for which the separation between is greater than the\r\n    // minimum tick separation.\r\n    let sliderWidth = this._sliderDimensions.width;\r\n\r\n    // This is the total \"width\" of the slider in terms of values.\r\n    let valueWidth = this.max - this.min;\r\n\r\n    // Calculate how many values exist within 1px on the slider.\r\n    let valuePerPixel = valueWidth / sliderWidth;\r\n\r\n    // Calculate how many values exist in the minimum tick separation (px).\r\n    let valuePerSeparation = valuePerPixel  * MIN_AUTO_TICK_SEPARATION;\r\n\r\n    // Calculate how many steps exist in this separation. This will be the lowest value you can\r\n    // multiply step by to get a separation that is greater than or equal to the minimum tick\r\n    // separation.\r\n    let stepsPerSeparation = Math.ceil(valuePerSeparation / this.step);\r\n\r\n    // Get the percentage of the slider for which this tick would be located so we can then draw\r\n    // it on the slider.\r\n    let tickPercentage = this.calculatePercentage((this.step * stepsPerSeparation) + this.min);\r\n\r\n    // The pixel value of the tick is the percentage * the width of the slider. Use this to draw\r\n    // the ticks on the slider.\r\n    this._renderer.drawTicks(sliderWidth * tickPercentage);\r\n  }\r\n\r\n  /**\r\n   * Calculates the separation of tick marks by finding the pixel value of the tickInterval.\r\n   */\r\n  private _updateTickSeparationFromInterval() {\r\n    // Force tickInterval to be a number so it can be used in calculations.\r\n    let interval: number = <number> this._tickInterval;\r\n    // Calculate the first value a tick will be located at by getting the step at which the interval\r\n    // lands and adding that to the min.\r\n    let tickValue = (this.step * interval) + this.min;\r\n\r\n    // The percentage of the step on the slider is needed in order to calculate the pixel offset\r\n    // from the beginning of the slider. This offset is the tick separation.\r\n    let tickPercentage = this.calculatePercentage(tickValue);\r\n    this._renderer.drawTicks(this._sliderDimensions.width * tickPercentage);\r\n  }\r\n\r\n  /**\r\n   * Calculates the percentage of the slider that a value is.\r\n   */\r\n  calculatePercentage(value: number) {\r\n    return (value - this.min) / (this.max - this.min);\r\n  }\r\n\r\n  /**\r\n   * Calculates the value a percentage of the slider corresponds to.\r\n   */\r\n  calculateValue(percentage: number) {\r\n    return this.min + (percentage * (this.max - this.min));\r\n  }\r\n\r\n  /**\r\n   * Return a number between two numbers.\r\n   */\r\n  clamp(value: number, min = 0, max = 1) {\r\n    return Math.max(min, Math.min(value, max));\r\n  }\r\n\r\n  /**\r\n   * Implemented as part of ControlValueAccessor.\r\n   * TODO: internal\r\n   */\r\n  writeValue(value: any) {\r\n    this.value = value;\r\n\r\n    if (this._sliderDimensions) {\r\n      this.snapThumbToValue();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implemented as part of ControlValueAccessor.\r\n   * TODO: internal\r\n   */\r\n  registerOnChange(fn: (value: any) => void) {\r\n    this._controlValueAccessorChangeFn = fn;\r\n  }\r\n\r\n  /**\r\n   * Implemented as part of ControlValueAccessor.\r\n   * TODO: internal\r\n   */\r\n  registerOnTouched(fn: any) {\r\n    this.onTouched = fn;\r\n  }\r\n}\r\n\r\n/**\r\n * Renderer class in order to keep all dom manipulation in one place and outside of the main class.\r\n */\r\nexport class SliderRenderer {\r\n  private _sliderElement: HTMLElement;\r\n\r\n  constructor(elementRef: ElementRef) {\r\n    this._sliderElement = elementRef.nativeElement;\r\n  }\r\n\r\n  /**\r\n   * Get the bounding client rect of the slider track element.\r\n   * The track is used rather than the native element to ignore the extra space that the thumb can\r\n   * take up.\r\n   */\r\n  getSliderDimensions() {\r\n    let trackElement = this._sliderElement.querySelector('.md-slider-track');\r\n    return trackElement.getBoundingClientRect();\r\n  }\r\n\r\n  /**\r\n   * Update the physical position of the thumb and fill track on the slider.\r\n   */\r\n  updateThumbAndFillPosition(percent: number, width: number) {\r\n    // A container element that is used to avoid overwriting the transform on the thumb itself.\r\n    let thumbPositionElement =\r\n        <HTMLElement>this._sliderElement.querySelector('.md-slider-thumb-position');\r\n    let fillTrackElement = <HTMLElement>this._sliderElement.querySelector('.md-slider-track-fill');\r\n\r\n    let position = Math.round(percent * width);\r\n\r\n    fillTrackElement.style.width = `${position}px`;\r\n    applyCssTransform(thumbPositionElement, `translateX(${position}px)`);\r\n  }\r\n\r\n  /**\r\n   * Focuses the native element.\r\n   * Currently only used to allow a blur event to fire but will be used with keyboard input later.\r\n   */\r\n  addFocus() {\r\n    this._sliderElement.focus();\r\n  }\r\n\r\n  /**\r\n   * Draws ticks onto the tick container.\r\n   */\r\n  drawTicks(tickSeparation: number) {\r\n    let tickContainer = <HTMLElement>this._sliderElement.querySelector('.md-slider-tick-container');\r\n    let tickContainerWidth = tickContainer.getBoundingClientRect().width;\r\n    // An extra element for the last tick is needed because the linear gradient cannot be told to\r\n    // always draw a tick at the end of the gradient. To get around this, there is a second\r\n    // container for ticks that has a single tick mark on the very right edge.\r\n    let lastTickContainer =\r\n        <HTMLElement>this._sliderElement.querySelector('.md-slider-last-tick-container');\r\n    // Subtract 1 from the tick separation to center the tick.\r\n    // TODO: Evaluate the rendering performance of using repeating background gradients.\r\n    tickContainer.style.background = `repeating-linear-gradient(to right, black, black 2px, ` +\r\n        `transparent 2px, transparent ${tickSeparation - 1}px)`;\r\n    // Add a tick to the very end by starting on the right side and adding a 2px black line.\r\n    lastTickContainer.style.background = `linear-gradient(to left, black, black 2px, transparent ` +\r\n        `2px, transparent)`;\r\n\r\n    // If the second to last tick is too close (a separation of less than half the normal\r\n    // separation), don't show it by decreasing the width of the tick container element.\r\n    if (tickContainerWidth % tickSeparation < (tickSeparation / 2)) {\r\n      tickContainer.style.width = tickContainerWidth - tickSeparation + 'px';\r\n    }\r\n  }\r\n}\r\n\r\n\r\n@NgModule({\r\n  imports: [FormsModule],\r\n  exports: [MdSlider],\r\n  declarations: [MdSlider],\r\n  providers: [\r\n    {provide: HAMMER_GESTURE_CONFIG, useClass: MdGestureConfig},\r\n  ],\r\n})\r\nexport class MdSliderModule {\r\n  static forRoot(): ModuleWithProviders {\r\n    return {\r\n      ngModule: MdSliderModule,\r\n      providers: [{provide: HAMMER_GESTURE_CONFIG, useClass: MdGestureConfig}]\r\n    };\r\n  }\r\n}\r\n"],"sourceRoot":"/source/"}